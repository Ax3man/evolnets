#' Calculate the posterior probability of ancestral host repertoires at time points in the past (ages)
#'
#' @param history Data frame with posterior samples of interaction histories. Output from `read_history()`.
#' @param ages Vector of ages (time points in the past) at which samples will be retrieved. The
#'   present (age = 0) must be included.
#' @param tree Symbiont tree.
#' @param host_tree Host tree.
#' @param extant_prob Should posterior probabilities be calculated for extant network? Default to
#'   FALSE. TRUE only makes sense if interactions in the extant network were also inferred. When
#'   FALSE, only the first MCMC sample will be retrieved at age = 0.
#' @param state Probabilities will be calculated only for this state. Default is 2. For analyses
#'   using the 3-state model, can take the values 1 (potential host) or 2 (actual host). For
#'   analyses using the 2-state model, state = 1 is ignored.
#' @param drop_empty Logical. Remove taxa without any interactions?
#'
#' @return A list of three lists, containing:
#' \itemize{
#'  \item{"`samples`"}{ Arrays of samples x nodes x hosts, containing the state of each sample.}
#'  \item{"`post_states`"}{ Arrays of nodes x hosts x state containing the posterior probability
#'  for each state.}
#'  \item{"`post_repertoires`"}{ Arrays of nodes x hosts x repertoire containing the posterior
#'  probability for 1) the `"realized"` repertoire which is defined as state 2, and 2) the
#'  `"fundamental"` repertoire which is defined as having any state (usually 1 or 2).}
#' }
#' Each array in these lists is for one of the `ages`. The number of samples is the number of
#' iterations in `history`.
#' @export
#'
#' @examples
#' # read symbiont and host tree
#' data(tree)
#' data(host_tree)
#'
#' # read histories sampled during MCMC
#' data(history)
#'
#' # get samples at ages
#' ages <- c(80,70,0)
#' at_ages <- posterior_at_ages(history, ages, tree, host_tree)
#' samples_at_ages <- at_ages$samples
#'
#' # get posterior probabilities at ages
#' pp_at_ages <- at_ages$post_states
posterior_at_ages <- function(history, ages, tree, host_tree, extant_prob = FALSE, state = 2, drop_empty = TRUE) {

  # input checking
  if (!is.data.frame(history)) {
    stop('`history` should be a data.frame, usually generated by `read_history()`')
  }
  if (!all(c('node_index', 'iteration', 'transition_type') %in% names(history))) {
    stop('`history` needs to have columns `node_index`, `iteration` and `transition_type`.')
  }
  if (!is.numeric(ages)) stop('`ages` should be a numeric vector.')
  if (!(0 %in% ages)) stop('`ages` has to include 0 (the present).')
  origin <- max(dispRity::tree.age(tree)$ages)
  if (max(ages) > origin) stop('all `ages` must be younger than the origin of the symbiont clade.')
  if (!inherits(tree, 'phylo')) stop('`tree` should be a phylogeny of class `phylo`.')
  if (!inherits(host_tree, 'phylo')) stop('`host_tree` should be a phylogeny of class `phylo`.')
  if (!is.numeric(state)) stop('`state` should be a numeric vector.')
  if (!is.logical(drop_empty) | length(drop_empty) != 1) {
    stop('`drop_empty` should be a logical vector of length 1.')
  }

  # get the posteriors
  l <- list()

  for (i in seq_along(ages)) {
    age <- ages[i]

    if (!extant_prob & age == 0) {
      l[[i]] <- make_samples_post_at_age(
        history[history$iteration == history$iteration[1], ],
        age, tree, host_tree, state, drop_empty
      )
    } else {
      l[[i]] <- make_samples_post_at_age(
        history, age, tree, host_tree, state, drop_empty
      )
    }

  }
  names(l) <- ages
  purrr::transpose(l)
}

make_samples_post_at_age <- function(dat, age, tree, host_tree, state, drop_empty) {

  iterations <- sort(unique(dat$iteration))
  n_iter <- length(iterations)

  nodes <- sort(unique(dat$node_index))
  n_nodes <- length(nodes)
  node_names <- c(rev(tree$tip.label), paste0("Index_", (((n_nodes + 1) / 2) + 1):length(nodes)))

  # Apply `make_dat_age` to each iteration, then join them all together.
  # This is the slowest step of the function.
  dat2 <- purrr::map_dfr(split(dat, dat$iteration), make_dat_age, age = age)

  dat2 <- dat2 %>%
    # Select only the columns we need
    dplyr::select(.data$iteration, .data$node_index, .data$end_state) %>%
    dplyr::mutate(
      # Keep making factors so we do not accidentally drop iterations or nodes
      iteration = factor(.data$iteration, iterations),
      node_index = factor(.data$node_index, nodes),
      # Split the state string up to create one observation per node
      end_state = stringr::str_split(.data$end_state, ""),
      # add indices for the hosts
      s_index = list(seq_along(.data$end_state[[1]]))
    ) %>%
    # Put each node on it's own row
    tidyr::unnest(c(.data$end_state, .data$s_index)) %>%
    # Keep making factors so we do not accidentally drop states or hosts
    dplyr::mutate(
      end_state = factor(.data$end_state, state),
      s_index = factor(.data$s_index)
    ) %>%
    # Drop everything where the state was '0'
    dplyr::filter(.data$end_state != '0')

  # Now count all combinations to make our samples array
  all_combs <- unclass(table(dat2$iteration, dat2$node_index, dat2$s_index, dat2$end_state))
  if (!all(all_combs %in% c(0, 1))) {
    # Just in case something has gone horribly wrong.
    stop('Duplicated combinations detected, please contact the maintainer of evolnets.')
  }
  # We have to assign the correct state, so loop through the possible states and assign the state
  # to wherever an interaction was found (i.e. count == 1)
  l <- list()
  for (s in seq_along(state)) {
    # we need to be careful here, we want to drop dimension 4 (state), but not any other. For
    # example, for extant networks, we may only have 1 iteration. You can't easily drop a specific
    # array dimension in R, while keeping dimnames, so that's why this is a bit convoluted.
    a <- all_combs[, , , s, drop = FALSE]
    dm <- dimnames(a)
    dim(a) <- dim(a)[1:3]
    dimnames(a) <- dm[1:3]
    a[a == 1] <- state[s]
    l[[s]] <- a
  }
  # Then we merge the arrays for each state. We take the first array, and overwrite the elements
  # where the second array is non-null with elements of the second. Repeat for a possible third
  # state etc. (I don't think there is a third state, but this generalizes to n states.)
  array <- Reduce(function(x, y) { x[y != 0] <- y[y != 0]; return(x) }, l)
  # The line above should have the same result as the sum below, but the sum is much slower
  #array <- apply(array, 1:3, sum)
  # Finally we assign names to the array
  dimnames(array) <- list(seq_len(n_iter), node_names, host_tree$tip.label)

  # For the probabilities arrays, we just need to count and divide by total iterations
  # First, make an array of the posterior probabilities for each state
  p_st <- unclass(table(dat2$node_index, dat2$s_index, dat2$end_state))
  p_st <- p_st / n_iter
  dimnames(p_st) <- list(node_names, host_tree$tip.label, state)
  # Then, make an array that has the realized repertoire (state 2), and the fundamental repertoire
  # (sum of the probabilities of all states)
  p_rep <- array(0, c(dim(p_st)[1:2], 2), c(dimnames(p_st)[1:2], list(c('realized', 'fundamental'))))
  if (2 %in% state) p_rep[, , 1] <- p_st[, , '2']
  p_rep[, , 2] <- apply(p_st, 1:2, sum)

  if (drop_empty) {
    symbionts_present <- rowSums(p_st) != 0
    hosts_present <- apply(p_st, 2, sum) != 0
    array <- array[, symbionts_present, hosts_present, drop = FALSE]
    p_st  <-  p_st[symbionts_present, hosts_present, , drop = FALSE]
    p_rep <- p_rep[symbionts_present, hosts_present, , drop = FALSE]
  }

  list(samples = array, post_states = p_st, post_repertoires = p_rep)
}

# find lineages (and their repertoires) that exist during the specified age
make_dat_age <- function(dat, age) {

  # reduce the history data frame to only include relevant branches
  dat2 <- dat[dat$branch_start_time >= age & dat$branch_end_time <= age, ]

  nodes <- unique(dat2$node_index)

  dat3 <- rbind(
    dat2[dat2$transition_type == "no_change", ],
    dat2[dat2$transition_type == "anagenetic" & dat2$transition_time >= age, ]
  )

  ret <- list()
  for (i in seq_along(nodes)) {
    if (!(nodes[i] %in% dat3$node_index)) {             # if changes happened only after age
      parent <- dat[dat$node_index == nodes[i], 12][1]  # get state at parent node
      dat4 <- dat[dat$node_index == parent, ]
      dat4$node_index <- nodes[i]                       # fix node_index - back to child nodes
      if (nrow(dat4) == 1) {                            # when type is no_change, time is NA and which.min doesn't work
        ret[[i]] <- dat4
      } else{
        ret[[i]] <- dat4[which.min(dat4$transition_time), ]
      }
    } else {
      dat4 <- dat3[dat3$node_index == nodes[i], ]
      if (nrow(dat4) == 1) {
        ret[[i]] <- dat4
      } else{
        ret[[i]] <- dat4[which.min(dat4$transition_time), ]  # get state at minimum, not maximum time (that is greater than age)
      }
    }
  }
  return(data.table::rbindlist(ret))
}

