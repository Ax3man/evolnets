#' Calculate the posterior probability of ancestral host repertoires at time points in the past (ages)
#'
#' @param history Data frame with posterior samples of interaction histories. Output from `read_history()`.
#' @param ages Vector of ages (time points in the past) at which samples will be retrieved. The present (age = 0) must be included.
#' @param tree Symbiont tree.
#' @param host_tree Host tree.
#' @param extant_prob Should posterior probabilities be calculated for extant network? Default to FALSE. TRUE only makes sense if interactions in the extant network were also inferred. When FALSE, only the first MCMC sample will be retrieved at age = 0.
#' @param state Probabilities will be calculated for which state? Default is 2. For analyses using the 3-state model, can take the values 1 (potential host) or 2 (actual host). For analyses using the 2-state model, state = 1 is ignored.
#' @param drop_empty Logical. Remove taxa without any interactions?
#'
#' @return A list of arrays of samples x symbionts x hosts (first element) and a matrix of
#'   posterior probabilities (second element). The number of samples is the number of
#'   iterations in `history`. At each age, all hosts and all extant symbiont lineages are included.
#' @export
#'
#' @examples
#' # read symbiont and host tree
#' data(tree)
#' data(host_tree)
#'
#' # read histories sampled during MCMC
#' data(history)
#'
#' # get samples at ages
#' ages <- c(80,70,0)
#' at_ages <- posterior_at_ages(history, ages, tree, host_tree)
#' samples_at_ages <- at_ages$samples
#'
#' # get posterior probabilities at ages
#' pp_at_ages <- at_ages$posterior_probabilities
posterior_at_ages <- function(history, ages, tree, host_tree, extant_prob = FALSE, state = 2, drop_empty = TRUE) {

  # input checking
  if (!is.data.frame(history)) {
    stop('`history` should be a data.frame, usually generated by `read_history()`')
  }
  if (!all(c('node_index', 'iteration', 'transition_type') %in% names(history))) {
    stop('`history` needs to have columns `node_index`, `iteration` and `transition_type`.')
  }
  if (!is.numeric(ages)) stop('`ages` should be a numeric vector.')
  if (!(0 %in% ages)) stop('`ages` has to include 0 (the present).')
  if (!inherits(tree, 'phylo')) stop('`tree` should be a phylogeny of class `phylo`.')
  if (!inherits(host_tree, 'phylo')) stop('`host_tree` should be a phylogeny of class `phylo`.')
  if (!is.numeric(state)) stop('`state` should be a numeric vector.')
  if (!is.logical(drop_empty) | length(drop_empty) != 1) {
    stop('`drop_empty` should be a logical vector of length 1.')
  }

  # get the posteriors
  samp_ages <- post_ages <- list()

  for (i in seq_along(ages)) {
    age <- ages[i]

    if (!extant_prob & age == 0) {
      ages_samp_post <- get_extant_binary_network(history, tree, host_tree, state, drop_empty)
    } else{
      ages_samp_post <- make_samples_post_at_age(history, age, tree, host_tree, state, drop_empty)
    }

    samp_ages[[i]] <- ages_samp_post[[1]]
    post_ages[[i]] <- ages_samp_post[[2]]

  }

  names(samp_ages) <- names(post_ages) <- ages
  samp_post_ages <- list(samp_ages, post_ages)
  names(samp_post_ages) <- c("samples", "posterior_probabilities")

  return(samp_post_ages)

}


get_extant_binary_network <- function(dat, tree, host_tree, state, drop_empty) {

  iterations <- sort(unique(dat$iteration))
  n_iter <- 1

  # get dimensions
  n_host_tip <- nchar(dat$start_state[1])
  n_parasite_lineage <- dplyr::n_distinct(dat$node_index)
  n_parasite_tip <- (n_parasite_lineage + 1) / 2

  m_names <- list(
    seq_len(n_iter),
    c(rev(tree$tip.label), paste0("Index_", (n_parasite_tip + 1):n_parasite_lineage)),
    host_tree$tip.label
  )

  m_sample <- array(0, dim = c(n_iter, n_parasite_lineage, n_host_tip), dimnames = m_names)
  m_posterior <- matrix(data = 0, nrow = n_parasite_lineage, ncol = n_host_tip, dimnames = m_names[2:3])

  it <- iterations[1]

  # get dataset for iteration
  dat_it <- dat[dat$iteration == it, ]

  # extract relevant branches
  dat_it <- make_dat_age(dat_it, age = 0)

  # add edges ( parasite x host )
  for (i in seq_len(nrow(dat_it))) {
    n_idx <- dat_it$node_index[i]
    s <- as.numeric(stringr::str_split(dat_it$end_state[i], "")[[1]])
    s_idx <- s %in% state

    m_sample[it_idx, n_idx, s_idx] <- state
    m_posterior[n_idx, s_idx] <- m_posterior[n_idx, s_idx] + 1
  }

  # remove empty rows/columns
  if (drop_empty) {
    m_posterior <- m_posterior[rowSums(m_posterior) != 0, ]
    m_posterior <- m_posterior[, colSums(m_posterior) != 0]
  }

  samp_post <- list(m_sample, m_posterior)

  return(samp_post)
}


make_samples_post_at_age <- function(dat, age, tree, host_tree, state, drop_empty) {

  iterations <- sort(unique(dat$iteration))
  n_iter <- length(iterations)

  # get dimensions
  n_host_tip <- nchar(dat$start_state[1])
  n_parasite_lineage <- dplyr::n_distinct(dat$node_index)
  n_parasite_tip <- (n_parasite_lineage + 1) / 2

  m_names <- list(
    seq_len(n_iter),
    c(rev(tree$tip.label), paste0("Index_", (n_parasite_tip + 1):n_parasite_lineage)),
    host_tree$tip.label
  )

  m_sample <- array(0, dim = c(n_iter, n_parasite_lineage, n_host_tip), dimnames = m_names)
  m_posterior <- matrix(data = 0, nrow = n_parasite_lineage, ncol = n_host_tip, dimnames = m_names[2:3])

  for (it_idx in seq_along(iterations)) {
    it <- iterations[it_idx]

    # get dataset for iteration
    dat_it <- dat[dat$iteration == it, ]

    # extract relevant branches
    dat_it <- make_dat_age(dat_it, age)

    # add edges ( parasite x host )
    for (i in seq_len(nrow(dat_it))) {
      n_idx <- dat_it$node_index[i]
      s <- as.numeric(stringr::str_split(dat_it$end_state[i], "")[[1]])
      s_idx <- s %in% state

      m_sample[it_idx, n_idx, s_idx] <- state
      m_posterior[n_idx, s_idx] <- m_posterior[n_idx, s_idx] + 1
    }
  }

  # remove empty rows/columns
  if (drop_empty) {
    m_posterior <- m_posterior[rowSums(m_posterior) != 0, ]
    m_posterior <- m_posterior[, colSums(m_posterior) != 0]
  }

  # convert to probability
  m_posterior <- m_posterior * (1 / n_iter)
  samp_post <- list(m_sample, m_posterior)

  return(samp_post)
}



# find lineages (and their repertoires) that exist during the specified age
make_dat_age <- function(dat, age) {

  # reduce the history data frame to only include relevant branches
  dat2 <- dat[dat$branch_start_time >= age & dat$branch_end_time <= age, ]

  nodes <- unique(dat2$node_index)

  dat3 <- rbind(
    dat2[dat2$transition_type == "no_change", ],
    dat2[dat2$transition_type == "anagenetic" & dat2$transition_time >= age, ]
  )

  ret <- list()
  for (i in seq_along(nodes)) {
    if (!(nodes[i] %in% dat3$node_index)) {             # if changes happened only after age
      parent <- dat[dat$node_index == nodes[i], 12][1]  # get state at parent node
      dat4 <- dat[dat$node_index == parent, ]
      dat4$node_index <- nodes[i]                       # fix node_index - back to child nodes
      if (nrow(dat4) == 1) {                            # when type is no_change, time is NA and which.min doesn't work
        ret[[i]] <- dat4
      } else{
        ret[[i]] <- dat4[which.min(dat4$transition_time), ]
      }
    } else {
      dat4 <- dat3[dat3$node_index == nodes[i], ]
      if (nrow(dat4) == 1) {
        ret[[i]] <- dat4
      } else{
        ret[[i]] <- dat4[which.min(dat4$transition_time), ]  # get state at minimum, not maximum time (that is greater than age)
      }
    }
  }
  return(data.table::rbindlist(ret))
}

